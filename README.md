# Disclaimer

## AI Use

AI Prompting or agents were not used to generate the core code base except the `README.md` and `./src/test/test.rs`. These two files were generated by Github Copilot. Furthermore, I do use Github Copilot's autocomplete, which were enabled whie I was writing codes.

This disclaimer is not written / modified by any AI agents.


# Transaction Engine

A high-performance, async-based transaction processing engine written in Rust. This application processes financial transactions (deposits, withdrawals, disputes, resolutions, and chargebacks) for multiple clients with support for both normal and batch processing modes.

## Features

- **Asynchronous Processing**: Non-blocking I/O with Tokio async runtime
- **Streaming CSV Input**: Process large CSV files efficiently without loading entire file into memory
- **Per-Client Worker Tasks**: Spawn dedicated async tasks for each client to handle transactions concurrently
- **Dispute Management**: Full support for disputes, resolutions, and chargebacks
- **Account Locking**: Accounts are automatically locked after a chargeback
- **Batch Mode**: Continue processing on transaction errors instead of halting
- **Precise Decimal Output**: 4 decimal place precision for all monetary amounts
- **Comprehensive Testing**: Extensive test suite covering normal operations and edge cases

## Building

### Prerequisites

- Rust 1.70+ (for async/await and latest features)
- Cargo

### Build

```bash
cargo build --release
```

## Usage

### Basic Usage (Normal Mode)

```bash
cargo run -- path/to/transactions.csv
```

In normal mode, the engine continues processing transactions and silently skips any that fail due to business logic errors (e.g., insufficient funds). File parsing errors still halt processing.

### Batch Mode

```bash
cargo run -- path/to/transactions.csv --batch
```

In batch mode, processing halts immediately on the first transaction error with exit code 1.

## CSV Format

Input CSV format:

```csv
type,client,tx,amount
deposit,1,1,100.50
withdrawal,1,2,50.00
dispute,1,1,
resolve,1,1,
chargeback,1,1,
```

### Columns

- **type**: Transaction type (deposit, withdrawal, dispute, resolve, chargeback)
- **client**: Client ID (u16, 0-65535)
- **tx**: Transaction ID (u32, 0-4294967295)
- **amount**: Amount in currency units (f64, optional for dispute/resolve/chargeback)

### Transaction Types

| Type | Description | Amount Required | Effect |
|------|-------------|-----------------|--------|
| **deposit** | Add funds to account | Yes | available += amount, total += amount |
| **withdrawal** | Remove funds from account | Yes | available -= amount, total -= amount (fails if insufficient) |
| **dispute** | Hold funds from previous deposit | No | available -= amount, held += amount (moves disputed funds) |
| **resolve** | Release held funds back to available | No | held -= amount, available += amount |
| **chargeback** | Deduct held funds and lock account | No | total -= amount, locked = true |

## Output

The application outputs client account states to stdout in CSV format with 4 decimal precision:

```csv
client,available,held,total,locked
1,100.0000,50.0000,150.0000,false
2,200.0000,0.0000,200.0000,true
```

### Output Columns

- **client**: Client ID
- **available**: Funds available for withdrawal
- **held**: Funds currently in dispute (held)
- **total**: Total funds (available + held)
- **locked**: Whether account is locked (true after chargeback)

## Architecture

### Core Components

#### `ClientAccount` (src/models/account.rs)

Represents a single client's account with balance tracking and transaction application logic.

**Key Methods:**
- `deposit(amount)`: Increase available and total funds
- `withdraw(amount)`: Decrease available and total funds (fails if insufficient)
- `dispute(amount)`: Move amount from available to held
- `resolve(amount)`: Move amount from held back to available
- `chargeback(amount)`: Deduct from total, lock account
- `apply_transaction_record()`: Apply transaction and update state

**State:**
- `client: u16` - Client ID
- `available: f64` - Funds available for withdrawal
- `held: f64` - Funds in dispute
- `total: f64` - Total funds (available + held)
- `locked: bool` - Account locked flag

#### `TransactionEngineService` (src/service/transaction_engine.rs)

Main service coordinating transaction processing across multiple clients.

**Key Features:**
- Spawns async worker task per client
- Routes transactions via message channels
- Streams CSV input without buffering entire file
- Outputs formatted results asynchronously

**Methods:**
- `new()`: Create new engine service
- `begin_transactions_from_file(path, batch_mode)`: Process CSV file
- `print_client_accounts()`: Output account states (4 decimal precision)

#### Message-Based Architecture

Uses Tokio `mpsc` channels for per-client workers:
- **Producer**: CSV reader streams transactions
- **Consumer**: Per-client async task processes messages
- **Message Types**: `TransactionRecord` (process) | `Terminate` (stop)

### Processing Flow

```
CSV File
   ↓
[Async CSV Reader - Streaming]
   ↓
[Client Router]
   ├→ [Client 1 Worker Task] → Process Tx → Update Account
   ├→ [Client 2 Worker Task] → Process Tx → Update Account
   └→ [Client N Worker Task] → Process Tx → Update Account
   ↓
[Shared State: Arc<Mutex<HashMap<ClientAccount>>>]
   ↓
[Format & Stream Output (4 decimal places)]
   ↓
stdout
```

## Business Logic

### Transaction Processing Rules

#### Deposit
- Increases `available` and `total` funds
- Duplicate deposit IDs are rejected
- Amount field is required
- Creates transaction record for future disputes

#### Withdrawal
- Decreases `available` and `total` funds
- **Fails if** `available < amount`
- Amount field is required
- Does not create disputable record

#### Dispute
- Moves amount from `available` to `held`
- **Fails if** `available < amount` (insufficient available funds)
- References previous deposit via transaction ID
- Only one active dispute per transaction
- **Fails if** transaction already disputed
- Amount determined by original deposit, not specified in CSV

#### Resolve
- Moves amount from `held` back to `available`
- **Fails if** transaction not currently disputed
- Returns disputed funds without penalty
- Clears dispute status

#### Chargeback
- Decreases `total` by held amount
- Sets `held` to 0
- Sets `locked` to `true`
- **Fails if** transaction not currently disputed
- **Effect**: Account becomes permanently locked
- All future operations on locked account are rejected

### Account Locking

Once an account is locked:
- ✗ Cannot deposit
- ✗ Cannot withdraw
- ✗ Cannot dispute
- ✗ Cannot resolve
- ✗ Cannot chargeback
- Only valid state display (read-only)

### State Transition Diagram

```
[Deposit Created]
       ↓
   [Normal]
   /      \
  /        \
[Dispute]   [Complete]
 / | \
/  |  \
D  R   C
│  │   │
│  │   └→ [Charged Back] → LOCKED
│  │
│  └────→ [Resolved] → [Normal]
│
└────────→ [Disputed] (waiting for resolve/chargeback)

D = Dispute, R = Resolve, C = Chargeback
```

## Testing

### Run All Tests

```bash
cargo test
```

### Run Tests with Output

```bash
cargo test -- --nocapture
```

### Run Specific Test

```bash
cargo test test_dispute_and_chargeback
```

### Test Categories

**Basic Operations:**
- `test_sample_transactions` - Simple deposits and withdrawals
- `test_deposit_success` - Single deposit
- `test_withdraw_success` - Basic withdrawal
- `test_withdraw_insufficient_funds` - Insufficient funds error

**Dispute & Resolve:**
- `test_dispute_and_resolve` - Full dispute-resolve cycle
- `test_dispute_and_resolve_with_withdrawal` - Dispute after partial withdrawal
- `test_multiple_disputes_and_resolves` - Multiple transactions disputed
- `test_resolve_without_dispute_ignored` - Orphaned resolve is ignored

**Dispute & Chargeback:**
- `test_dispute_and_chargeback` - Full dispute-chargeback cycle
- `test_chargeback_locks_account_from_further_operations` - Account locking
- `test_chargeback_with_held_funds` - Chargeback reduces total correctly
- `test_chargeback_on_non_disputed_ignored` - Orphaned chargeback ignored

**Account Locking:**
- `test_locked_account_rejects_operations` - Locked account blocks all operations
- `test_chargeback_locks_account` - Chargeback sets locked=true

**Batch Mode:**
- `test_sample_transactions_batch_mode` - Batch mode basic operation
- `test_resolve_with_insufficient_held_batch_mode` - Batch continues on errors
- `test_chargeback_with_insufficient_held_batch_mode` - Batch skip failed chargebacks

**Complex Scenarios:**
- `test_complex_workflow_multiple_clients` - Multi-client transactions
- `test_partial_dispute_with_resolution` - Dispute after withdrawal
- `test_multiple_transactions_same_client_with_chargeback` - Multiple deposits then chargeback

### Test Coverage Summary

- 30+ unit tests covering all transaction types
- Normal mode (continues on error) and batch mode (halts on error) tested
- Edge cases: locked accounts, insufficient funds, invalid transitions
- Multi-client scenarios
- 4 decimal place precision verification

## Error Handling

### Normal Mode

**Processing continues despite transaction errors. Failed transactions are silently skipped.**

- ✅ Continues to next transaction on business logic errors
- ✅ File parsing errors still halt (malformed CSV)
- ✅ Returns exit code 0 if file parsing succeeds
- ✅ Processes all valid transactions

**Use cases:**
- Production data with occasional invalid records
- Data migration with lenient validation
- Non-critical transaction processing

Example:
```bash
$ cargo run -- transactions.csv
# Skips failed transactions, outputs successful accounts
client,available,held,total,locked
1,50.0000,0.0000,50.0000,false
```

### Batch Mode

**Processing halts on the first transaction error with exit code 1.**

- ✗ Stops immediately on any business logic error
- ✗ File parsing errors also halt
- ✓ Returns exit code 1 on failure
- ✓ Enforces strict validation

**Use cases:**
- Critical financial operations requiring all-or-nothing
- Testing and validation scenarios
- Strict compliance requirements

Example:

### Error Types

| Error | Cause | Recovery |
|-------|-------|----------|
| `NotEnoughFunds` | available/held insufficient | None - transaction fails |
| `AccountLocked` | Account locked after chargeback | None - account permanent locked |
| `DuplicateRecord` | Duplicate deposit ID | None - duplicate rejected |
| `DisputeAlreadyExists` | Dispute transaction twice | None - only one dispute allowed |
| `InvalidTransactionFundAmount` | Missing required amount field | None - malformed transaction |
| `InvalidFilePath` | File not found | None - check path argument |

## Performance Characteristics

### Memory Usage

- **Constant**: O(1) memory growth during processing
- Transactions streamed line-by-line from CSV
- No accumulation of transaction records
- Account states stored in HashMap (number of clients × account size)

### Time Complexity

- **Per-transaction**: O(1) amortized (HashMap lookup + balance update)
- **Output**: O(n log n) where n = number of clients (sorting)
- **Overall**: O(m + n log n) where m = number of transactions, n = number of clients

### Async Benefits

- Non-blocking I/O - doesn't block event loop during file reads
- Per-client message channels - independent transaction processing
- Scalable to large files (GB+) and many clients

### Limitations

- Single-threaded async (Tokio single-threaded runtime)
- Mutex contention on shared `Arc<Mutex<>>` for high concurrency
- Float precision limited to f64 (double precision)

## Dependencies

```toml
[dependencies]
csv = "1.4.0"              # CSV parsing
csv-async = "1.3"         # Async CSV reading
tokio = { version = "1.42", features = ["full"] }  # Async runtime
serde = "1.0.228"         # Serialization framework
serde_derive = "1.0.228"  # Derive macros
clap = { version = "4", features = ["derive"] }    # CLI parsing
futures-util = "0.3"      # Async utilities
```

## Sample Transactions

### Example 1: Simple Deposit and Withdrawal

**Input:**
```csv
type,client,tx,amount
deposit,1,1,100.00
withdrawal,1,2,30.00
```

**Output:**
```csv
client,available,held,total,locked
1,70.0000,0.0000,70.0000,false
```

### Example 2: Dispute and Resolution

**Input:**
```csv
type,client,tx,amount
deposit,1,1,100.00
dispute,1,1,
resolve,1,1,
```

**Output:**
```csv
client,available,held,total,locked
1,100.0000,0.0000,100.0000,false
```

**Processing:**
1. Deposit: available=100, total=100
2. Dispute: available=0, held=100 (move from available to held)
3. Resolve: available=100, held=0 (move from held back to available)

### Example 3: Dispute and Chargeback

**Input:**
```csv
type,client,tx,amount
deposit,1,1,100.00
dispute,1,1,
chargeback,1,1,
```

**Output:**
```csv
client,available,held,total,locked
1,0.0000,0.0000,0.0000,true
```

**Processing:**
1. Deposit: available=100, total=100
2. Dispute: available=0, held=100
3. Chargeback: total=0 (100 removed), locked=true

### Example 4: Multiple Clients

**Input:**
```csv
type,client,tx,amount
deposit,1,1,50.00
deposit,2,2,100.00
withdrawal,1,3,20.00
dispute,2,2,
chargeback,2,2,
```

**Output:**
```csv
client,available,held,total,locked
1,30.0000,0.0000,30.0000,false
2,0.0000,0.0000,0.0000,true
```

## Running the Application

### Quick Start

```bash
# Clone repository
git clone <repo-url>

# Build
cargo build --release

# Run with sample data
./target/release/<project-path> ./src/test/sample_transactions.csv

# Run in batch mode
./target/release/<project-path> ./src/test/sample_transactions.csv --batch
```

### Troubleshooting

**File not found:**
```bash
Error: File not found: path/to/file.csv
```
Check that the file path is correct and file exists.

**CSV parsing error:**
```bash
Error: CSV error at line N: invalid field
```
Check CSV format - ensure all required columns present and types correct.

**Invalid transaction:**
```bash
Error: NotEnoughFunds
```
Check that client has sufficient available funds for operation.

## Known Limitations

- **Client IDs**: u16 (max 65,535 clients)
- **Transaction IDs**: u32 (max 4.29 billion transactions per lifetime)
- **Amounts**: f64 floating point (precision ~15-16 significant digits)
- **Precision**: 4 decimal places (sub-cent precision not supported)
- **Disputes**: Only apply to deposits, not withdrawals
- **No Persistence**: In-memory only, not persisted to database
- **No History**: Transaction records not available after processing
- **Single Instance**: No distributed processing or multi-node support

## Architecture Decisions

### Why Async?

- **Streaming**: Large files don't load into memory
- **Non-blocking**: Doesn't block other operations during I/O
- **Scalable**: Can handle thousands of clients with minimal overhead

### Why Message Channels?

- **Thread-safe**: Arc<Mutex> prevents data races
- **Decoupled**: Reader and processor independent
- **Concurrent**: Per-client tasks can process independently

### Why 4 Decimal Places?

- **Currency Standard**: Most currencies use 2-4 decimal places
- **Precision**: Sufficient for typical financial operations
- **Compatibility**: Standard in banking systems

### Why Batch Mode?

- **Flexibility**: Choose between strict (normal) or lenient (batch) processing
- **Production Use**: Batch mode for large datasets with occasional errors
- **Testing**: Normal mode for development validation

## Future Enhancements

- [ ] Database persistence (PostgreSQL, SQLite)
- [ ] Transaction history and audit log
- [ ] Fee calculations and interest accrual
- [ ] Refund operations
- [ ] Configurable decimal precision
- [ ] Metrics and monitoring (Prometheus)
- [ ] Webhook notifications for events
- [ ] Multi-node distributed processing
- [ ] Connection pooling for database
- [ ] Rate limiting and throttling
- [ ] Custom validation rules
- [ ] Data encryption at rest and in transit

## Contributing

Contributions are welcome! Please ensure:

```bash
# Format code
cargo fmt

# Check for warnings
cargo clippy

# Run all tests
cargo test

# Build release
cargo build --release
```

## Support

For questions, issues, or feature requests, please open an issue on the repository.

---

**Version**: 1.0.0  
**Last Updated**: December 4, 2025  
**Status**: Production Ready
